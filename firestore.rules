rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Original Rules (Restored) ---

    // Users can read and write their own profile document
    match /users/{userId} {
      allow read, update: if request.auth != null && request.auth.uid == userId;
      // Note: User creation is handled by signup logic, not direct writes.
    }

    // Doctors can manage their own patient records.
    // Patients can read their own records if their account is linked.
    match /patients/{patientId} {
      function isDoctorOwner() {
        // On read/update/delete, check existing document
        return request.auth.token.role == 'doctor' && request.auth.uid == get(/databases/$(database)/documents/patients/$(patientId)).data.doctorId;
      }
      function isCreator() {
        // On create, check incoming document
        return request.auth.token.role == 'doctor' && request.auth.uid == request.resource.data.doctorId;
      }
      function isPatientLinked() {
         return request.auth.token.role == 'patient' && request.auth.uid == resource.data.authUid;
      }

      allow create: if isCreator();
      allow read, update, delete: if isDoctorOwner();
      allow read: if isPatientLinked(); // Additive read permission for patients
    }

    // Doctors can manage the medicines they add to their database.
    match /medicines/{medicineId} {
       function isDoctorOwner() {
        return request.auth.token.role == 'doctor' && request.auth.uid == get(/databases/$(database)/documents/medicines/$(medicineId)).data.doctorId;
      }
      allow create: if request.auth.token.role == 'doctor' && request.auth.uid == request.resource.data.doctorId;
      allow read, update, delete: if isDoctorOwner();
    }

    // Doctors manage their appointments. Patients can read their own appointments.
    match /appointments/{appointmentId} {
      function isDoctorOwner() {
         return request.auth.token.role == 'doctor' && request.auth.uid == get(/databases/$(database)/documents/appointments/$(appointmentId)).data.doctorId;
      }
      function isPatientLinked() {
        let patientId = get(/databases/$(database)/documents/appointments/$(appointmentId)).data.patientId;
        let patientRecord = get(/databases/$(database)/documents/patients/$(patientId)).data;
        return request.auth.token.role == 'patient' && request.auth.uid == patientRecord.authUid;
      }

      allow create: if request.auth.token.role == 'doctor' && request.auth.uid == request.resource.data.doctorId;
      allow read, update, delete: if isDoctorOwner();
      allow read: if isPatientLinked(); // Additive read permission for patients
    }

    // --- New Chat Rules ---

    // A Chat Room document can be read/updated by its participants.
    // Creation is handled implicitly when the first message is sent.
    match /chatRooms/{roomId} {
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }

      allow get, update: if request.auth != null && isParticipant();
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants;
    }

    // Messages can be read or created by participants of the chat room.
    match /chatRooms/{roomId}/messages/{messageId} {
      function isParticipantByRoomId() {
        // The roomId is a composite key of `uid1_uid2`. This checks if the user's uid is in that key.
        return request.auth.uid in roomId.split('_');
      }

      // This rule is key: It allows creating/reading messages without needing to
      // read the parent chatRoom doc, which might not exist yet.
      allow read, create: if request.auth != null && isParticipantByRoomId();
      
      // For data integrity, prevent updating or deleting messages.
      allow update, delete: if false;
    }
  }
}
